{
  "swagger": "2.0",
  "schemes": [
    "http"
  ],
  "host": "staging-indexdb.services.interactives.dk",
  "basePath": "/api/v2",
  "info": {
    "title": "Index Search",
    "description": "This API alllows you to store your data in index data store which allows for extremely fast searching\n",
    "version": "2.0.0",
    "contact": {
      "email": "interactive@bonnier.dk"
    },
    "x-logo": {
      "url": "http://www.bonnier.com/Global/Images/Bonnier_logotype.png"
    }
  },
  "produces": [
    "application/json"
  ],
  "consumes": [
    "application/json"
  ],
  "tags": [
    {
      "name": "Search",
      "description": "## Query example\nIn V2 you are now able to parse an ElasticSearch query to our API and have it ported directly into ElasticSearch. This will be the primary way of querying for data.\n\nThis also means that you can use all the existing examples and documentation provided by ElasticSearch here [ElasticSearch Query Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/2.1/query-dsl.html).\n\nFor starters we suggest looking at the example below, and you can always contact us with questions or to help build any query functionality.\n**example query:**\n\n``` javascript\n{\n   \"locale\":\"da_dk\",\n   \"body\":{\n      \"size\":5,\n      \"query\":{\n         \"bool\":{\n            \"must\":{\n               \"multi_match\":{\n                  \"query\":\"moti\",\n                  \"fields\":[\n                     \"title.*\",\n                     \"description.*\",\n                     \"categories.*\",\n                     \"tags.*\"\n                  ],\n                  \"type\":\"most_fields\"\n               }\n            },\n            \"filter\":[\n               {\n                  \"term\":{\n                     \"brand_code\":\"kom\"\n                  }\n               },\n               {\n                  \"term\":{\n                     \"app_code\":\"fordelszonen\"\n                  }\n               }\n            ]\n         }\n      }\n   }\n}\n```\n\n\n**Success Response:**\n\n  **Code:** 200\n\n``` javascript\n\t{\n\t   \"total\":3,\n\t   \"max_score\":0,\n\t   \"hits\":[\n\t      {\n\t         \"app_code\":\"kom\",\n\t         \"brand_code\":\"fordelszonen\",\n\t         \"title\":\"Simple Motions 2\"\n\t         ...\n\t      }\n\t   ]\n\t}\n\t```\n\n**Error Response:**\n\nRequesting with an incorrect query will return an error code 400. This error is generated by ElasticSearch and will return some information that might nessecarily not be useful for you, but potentially could help you in your search for the error.\n\n**Code:** 400 Bad Request\n\n``` javascript\n\t{\n\t   \"status\":400,\n\t   \"messages\":{\n\t      \"root_cause\":[\n\t         {\n\t            \"type\":\"query_parsing_exception\",\n\t            \"reason\":\"No query registered for [fs]\",\n\t            \"index\":\"content_da_dk\",\n\t            \"line\":1,\n\t            \"col\":20\n\t         }\n\t      ],\n\t      \"type\":\"search_phase_execution_exception\",\n\t      \"reason\":\"all shards failed\",\n\t      \"phase\":\"query\",\n\t      \"grouped\":true,\n\t      \"failed_shards\":[\n\t         {\n\t            \"shard\":0,\n\t            \"index\":\"content_da_dk\",\n\t            \"node\":\"JUWvVMQNRDqd42_Svxxe7Q\",\n\t            \"reason\":{\n\t               \"type\":\"query_parsing_exception\",\n\t               \"reason\":\"No query registered for [fs]\",\n\t               \"index\":\"content_da_dk\",\n\t               \"line\":1,\n\t               \"col\":20\n\t            }\n\t         }\n\t      ]\n\t   }\n\t}\n\t```\n**Notes:**\n\nPlease be adviced that when searching for data with an impartial string you can only get results when searching within the `title.*`, `description.*`, `tags.*` and `categories.*`. Doing full-text search in other then the mentioned fields will require an exact match of the exact string parsed. Meaning \"Sea\" will not match \"I am searching\", but will match \"I am under the sea\".\n\nFor title, description, tags and categories, it is also required that when doing fulltext search you append the field with `.*` to let the API know you are doing a fulltext search rather then an exact value query. This functionality is limited to the before specified fields only.\n\n### Additional Query Examples:\nBelow is a couple of examples on queries that will often be used.\n\n#### Pagination\nBelow query will fetch 50 items, starting from number 100, when specified app and brand code values.\n\n``` javascript\n{\n   \"locale\":\"da_dk\",\n   \"body\":{\n      \"size\":50,\n      \"from\":100,\n      \"query\":{\n         \"bool\":{\n            \"filter\":[\n               {\n                  \"term\":{\n                     \"brand_code\":\"kom\"\n                  }\n               },\n               {\n                  \"term\":{\n                     \"app_code\":\"fordelszonen\"\n                  }\n               }\n            ]\n         }\n      }\n   }\n}\n```\n\n#### [Sorting](https://www.elastic.co/guide/en/elasticsearch/reference/1.4/search-request-sort.html)\n\nBelow query will fetch 50 items, starting from number 100, when specified app and brand code values.\n\n``` javascript\n{\n   \"locale\":\"da_dk\",\n   \"body\":{\n\t   \"sort\":[\n\t      {\n\t         \"title\": { \"order\":\"asc\" }\n\t      }\n\t   ],\n      \"size\":50,\n      \"from\":100,\n      \"query\":{\n         \"bool\":{\n            \"filter\":[\n               {\n                  \"term\":{\n                     \"brand_code\":\"kom\"\n                  }\n               },\n               {\n                  \"term\":{\n                     \"app_code\":\"fordelszonen\"\n                  }\n               }\n            ]\n         }\n      }\n   }\n}\n```\n\n#### [Boosting](https://www.elastic.co/guide/en/elasticsearch/reference/2.1/query-dsl-query-string-query.html#_boosting)\nBelow query will search the content for moti and boost the \"ranking\" of those results which has moti in their title by 3 (notice: `\"title.*^3\"`), description by 2 (\"description.*^2\") and the rest by one.\n\nMeaning a if all of them contains the \"moti\" query, the title will give \"3 points\", description \"2 points\" and the rest \"1 point\". The data is then returned based on the average scoring of each document.\n\nThe default boost value is 1, but can be any positive floating point number. Boosts between 0 and 1 reduce relevance.\n\n``` javascript\n{\n   \"locale\":\"da_dk\",\n   \"body\":{\n      \"size\":5,\n      \"query\":{\n         \"bool\":{\n            \"must\":{\n               \"multi_match\":{\n                  \"query\":\"moti\",\n                  \"fields\":[\n                     \"title.*^3\",\n                     \"description.*^2\",\n                     \"categories.*\",\n                     \"tags.*\"\n                  ],\n                  \"type\":\"most_fields\"\n               }\n            },\n            \"filter\":[\n               {\n                  \"term\":{\n                     \"brand_code\":\"kom\"\n                  }\n               },\n               {\n                  \"term\":{\n                     \"app_code\":\"fordelszonen\"\n                  }\n               }\n            ]\n         }\n      }\n   }\n}\n\n```\n#### [Aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/2.1/search-aggregations.html):\n\nAggregations is one of the features that ElasticSearch allows us to do very nicely.\n\nLets imagine we are creating an application that shows a list of cars. We want to be able to filter this list of cars by brand, model and series. If we pick a value in the brand dropdown, say brand A, then we want the other filters to adjust accordingly, so that the other dropdowns do not show values in which no car with brand A exists.\n\nThis can be done with the following query\n\n``` javascript\n{\n   \"locale\":\"da_dk\",\n   \"body\":{\n      \"query\":{\n         \"bool\":{\n            \"filter\":[\n               {\n                  \"term\":{\n                     \"brand_code\":\"car\"\n                  }\n               },\n               {\n                  \"term\":{\n                     \"app_code\":\"carapp\"\n                  }\n               }\n            ]\n         }\n      },\n      \"aggregations\":{\n         \"brands\":{\n            \"terms\":{\n               \"field\":\"meta.brand\"\n            }\n         },\n         \"models\":{\n            \"terms\":{\n               \"field\":\"meta.model\"\n            }\n         },\n         \"series\":{\n            \"terms\":{\n               \"field\":\"meta.series\"\n            }\n         }\n      }\n   }\n}\n```\n\nReturns the following response\n\n``` javascript\n{\n  \"total\": 1,\n  \"max_score\": 9.260918,\n  \"hits\": [\n  \t\t...\n  ],\n  \"aggregations\": {\n    \"brands\": [\n      {\n        \"key\": \"BMW\",\n        \"doc_count\": 7\n      },\n      {\n        \"key\": \"Ferrari\",\n        \"doc_count\": 15\n      },\n      {\n        \"key\": \"Audi\",\n        \"doc_count\": 23\n      }\n    ],\n    \"models\": [\n      {\n        \"key\": \"A3\",\n        \"doc_count\": 7\n      },\n      {\n        \"key\": \"X6\",\n        \"doc_count\": 9\n      }\n    ],\n    \"series\": [\n      {\n        \"key\": \"Series 2\",\n        \"doc_count\": 1\n      }\n    ]\n  }\n}\n```\n\n#### [Search Request Fields](https://www.elastic.co/guide/en/elasticsearch/reference/2.1/search-request-fields.html):\n\nIf you know you are only going to be using certain fields for the document you can ask to only have those returned. This can be done with the following query:\n\n``` javascript\n{\n   \"locale\":\"da_dk\",\n   \"body\":{\n      \"fields\" : [\"title\", \"description\", \"image\", \"url\"],\n      \"query\":{\n         \"bool\":{\n            \"filter\":[\n               {\n                  \"term\":{\n                     \"brand_code\":\"car\"\n                  }\n               },\n               {\n                  \"term\":{\n                     \"app_code\":\"carapp\"\n                  }\n               }\n            ]\n         }\n      }\n   }\n}\n```\n\nReturns the following response\n\n``` javascript\n{\n  \"total\": 2,\n  \"max_score\": 0,\n  \"hits\": [\n    {\n      \"description\": \"Some description\",\n      \"image\": \"http://image.com/image.jpg\",\n      \"title\": \"Some Title\",\n      \"url\": \"http://some.url/here\",\n      \"id\": \"AVKDCR3M3p6shXKj93vw\",\n      \"score\": 0\n    },\n    {\n      \"description\": \"Some description\",\n      \"image\": \"http://image.com/image.jpg\",\n      \"title\": \"Some Title\",\n      \"url\": \"http://some.url/here\",\n      \"id\": \"FAKDCR3M3p6shXKj93vw\",\n      \"score\": 0\n    }\n  ]\n}\n```\n\n#### [Searching with And & Or](https://www.elastic.co/guide/en/elasticsearch/reference/current/compound-queries.html):\n\nGiven we want to find 'Cameras' and 'Printers' with the brand 'Canon' or 'Sony'.\n\nA query could be built like below that will query bool (true or false) on all documents and based on whether they have tags [Canon or Sony] AND categories [Camera or Printers].\n\n``` javascript\n{\n   \"locale\":\"da_dk\",\n   \"body\":{\n      \"size\":\"10\",\n      \"from\":0,\n      \"query\":{\n         \"bool\":{\n            \"must\":{\n               \"and\":[\n                  {\n                     \"or\":[\n                        {\n                           \"match\":{\n                              \"tags\":\"Canon\"\n                           }\n                        },\n                        {\n                           \"match\":{\n                              \"tags\":\"Sony\"\n                           }\n                        }\n                     ]\n                  },\n                  {\n                     \"or\":[\n                        {\n                           \"match\":{\n                              \"categories\":\"Kamera\"\n                           }\n                        },\n                        {\n                           \"match\":{\n                              \"categories\":\"Printere\"\n                           }\n                        }\n                     ]\n                  }\n               ]\n            },\n            \"filter\":[\n               {\n                  \"term\":{\n                     \"app_code\":\"productsearch\"\n                  }\n               }\n            ]\n         }\n      }\n   }\n}\n```\n#### [Suggesting](https://www.elastic.co/guide/en/elasticsearch/reference/current/suggester-context.html):\n\nBelow query we ask IS for suggestions to a search for the text \"Suk\".\n\nNotice that we have to add a context here. Contexts are available based on a combined app_code and brand_code. You cannot ask for suggestions across all content in IS.\n\n``` javascript\n{\n    \"locale\":\"da_dk\",\n    \"body\":{\n        \"size\":\"0\",\n        \"suggest\":{\n            \"text\":\"Suk\",\n            \"ingredients\":{\n                \"completion\":{\n                    \"field\":\"categories.suggest\",\n                    \"fuzzy\":{\n                        \"unicode_aware\":true\n                    },\n                    \"context\":{\n                        \"app_code\":\"site\",\n                        \"brand_code\":\"meal\"\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nReturns the following response\n\n``` javascript\n{\n  \"total\": 526,\n  \"max_score\": 0,\n  \"hits\": [],\n  \"suggest\": {\n    \"ingredients\": [\n      {\n        \"text\": \"Suk\",\n        \"offset\": 0,\n        \"length\": 3,\n        \"options\": [\n          {\n            \"text\": \"Sukker\",\n            \"score\": 41\n          },\n          {\n            \"text\": \"Skyr\",\n            \"score\": 10\n          },\n\t\t\t...\n        ]\n      }\n    ]\n  }\n}\n```\n"
    },
    {
      "name": "Teaser",
      "description": "\n## Understanding how we handle your data\n\nWhen you put data into ElasticSearch we take that data and store it in a number of different ways. Each way allows for you to search a specific way, or opens up for a special feature.\n\nThis section will go through how each of these different \"mappings\" will affect the ways in which you query for data.\n\n(***Notice***: an untouched version of your document will always be saved, it is this document that we return when you query. The fields mentioned below is only used for query and is added only to help specify and do more precise queries.)\n\n### Mapping Terms\n\nA teaser is composed of different fields each with its own mapping. The mapping controlls how the field value is indexed and plays a huge part in search performance.\n\nSo, to not repeat ourselves we will first introduce the different types of mapping that is possible, and then show which fields are mapped accordingly.\n\n 1. Lower Case\n\t* Saves all data as a lowercase string\n\t* Ex: 'Bob' -> 'bob'\n 2. Boolean\n\t* true/false\n\t* Ex: 'True' -> 'true'\n 3. Default Language\n\t* ***Enables country-specific localized searching*** This will use a dictionary (different for each language) to save each word in its stem-form. You don't have to consider this when quering it, since your query will go through the same dictionary. So that if you search for 'flying kites' you will actually search for 'fly kite'.\n\t* Ex: 'Peter loves flying kites' -> 'Peter love fly kite'\n 4. Autocomplete\n\t* ***Enables autocompletion***. Data in this field is saved multiple times and split into parts of the word. We split it into the first 2 characters, 3 characters, up to 10 characters. That way you can query this field ex: 'com' and get 'computer' back.\n\t* Ex: 'Computer Test' -> 'co', 'com', 'comp', ..., 'te', 'tes', 'test'.\n 5. Trigram\n\t* ***Enables query with spelling errors while still getting results.*** Data in this field is split into multiple small strings of 3  characters. This means that if you use this field to search for 'computer' you are actually searching for 'com', 'omp', 'mpu', etc. Meaning if you miss-spell 'kombuter' you are still going to get a match for 'computer' on 'ute', 'ter'. When quering like this matches are ordered by score (unless you override the sorting order) and the score can thus be used to filter out good relevance. Notice that the above query would also match 'ter' for 'terminal' and even 'router' as highly relevant since both 'ute' and 'ter' matches like it did with 'kombuter'. This should still be considered better then no results. (Consider showing a warning to users when the highest score gets too low, to inform that no exact matching content was found).\n\t* Ex: 'Computer Test' -> 'co', 'com', 'comp', ..., 'te', 'tes', 'test'.\n 6. Raw\n\t* ***Saves data exactly like it was input***. Data in this field is not manipulated. If you save 'Computer' or 'CoMpuTer' the data will be saved exactly like this. Be careful though, if you want to filter.\n\t* Ex: 'ComPutEr' -> 'ComPutEr'.\n\n### The mappings\n\nIt is important to note that each field can have multiple mappings. Ex. Title has a standard language mapping that is accessed through just 'title', but it also has a 'title.autocomplete', 'title.trigram', 'title.lowercase' and 'title.raw'.\n\n\n| Field  \t\t\t\t\t| Type | Mapping | Example |\n|:---\t\t\t\t\t\t|:---:\t|:---\t\t|---|\n| **app_code**  \t\t\t\t|string|lowercase|'Fordelszonen' -> 'fordelszonen'|\n| **brand_code** \t\t\t\t|string|lowercase|'Kom' -> 'kom'|\n| **active** \t\t\t\t\t|boolean|boolean|True -> true|\n| **content_type** \t\t\t|string|lowercase|'Article' -> 'article'|\n| **locale** \t\t\t\t\t|string|lowercase|'Da\\_Dk' -> 'da\\_dk'|\n| **title** \t\t\t\t\t|string|default language|'Watch Peter flying kites' -> 'watch peter fly kite'|\n| title.autocomplete \t|string|autocomplete |'Free cake' -> 'fr', 'fre', 'free', 'ca', 'cak', 'cake'|\n| title.trigram \t\t\t|string|trigram |'Cakes' -> 'cak', 'ake', 'kes'|\n| title.lowercase \t\t|string|lowercase|'Fruitcake' -> 'fruitcake'|\n| title.raw \t\t\t\t|string|raw|'CakE StoRm' -> 'CakE StoRm'|\n| **title\\_teaser** \t\t\t|string|default language|'Watch Peter flying kites' -> 'watch peter fly kite'|\n| title\\_teaser.autocomplete \t|string|autocomplete |'Free cake' -> 'fr', 'fre', 'free', 'ca', 'cak', 'cake'|\n| title\\_teaser.trigram \t\t\t|string|trigram |'Cakes' -> 'cak', 'ake', 'kes'|\n| title\\_teaser.lowercase \t\t|string|lowercase|'Fruitcake' -> 'fruitcake'|\n| title\\_teaser.raw \t\t\t\t|string|raw|'CakE StoRm' -> 'CakE StoRm'|\n| **description** \t\t|string|default language|'Watch Peter flying kites' -> 'watch peter fly kite'|\n| **descripntion\\_teaser** |string|default language|'Watch Peter flying kites' -> 'watch peter fly kite'|\n| **categories**\t\t\t   |string|default language| ['Flying', 'birds', 'nature'] -> ['fly', 'bird', 'nature']|\n| categories.autocomplete \t|string|autocomplete|['Flying', 'birds', 'nature'] -> ['fl', 'fly', 'flyi', 'flyin', 'flying' 'bi', 'bir', 'bird', 'birds', 'na', 'nat', 'natu', 'natur', 'nature']|\n| categories.trigram \t\t\t|string|trigram|['Flying', 'birds', 'nature'] -> ['fly', 'lyi', 'yin', 'ing', 'bir', 'ird', 'nat', 'atu', 'tur', 'ure']|\n| categories.lowercase \t\t|string|lowercase|['Flying', 'birds', 'nature'] -> ['flying', 'birds', 'nature']|\n| categories.raw \t\t\t\t|string|raw|['Flying', 'birds', 'NaTure'] -> ['Flying', 'birds', 'NaTure']|\n| **tags**\t\t\t   |string|default language| ['Flying', 'birds', 'nature'] -> ['fly', 'bird', 'nature']|\n| categories.autocomplete \t|string|autocomplete|['Flying', 'birds', 'nature'] -> ['fl', 'fly', 'flyi', 'flyin', 'flying' 'bi', 'bir', 'bird', 'birds', 'na', 'nat', 'natu', 'natur', 'nature']|\n| categories.trigram \t\t\t|string|trigram|['Flying', 'birds', 'nature'] -> ['fly', 'lyi', 'yin', 'ing', 'bir', 'ird', 'nat', 'atu', 'tur', 'ure']|\n| categories.lowercase \t\t|string|lowercase|['Flying', 'birds', 'nature'] -> ['flying', 'birds', 'nature']|\n| categories.raw \t\t\t\t|string|raw|['Flying', 'birds', 'NaTure'] -> ['Flying', 'birds', 'NaTure']|\n| **body** |string|default language|'Here we are watching peter flying with kites' -> 'here watch peter fly kite'|\n| **url** |string|url|www.url.com -> http://www.url.com|\n| **image** |string|not_analyzed|http://www.UrL.com -> http://www.UrL.com|\n| **published\\_at** |string|date|'08-02-2016'->'08-02-2016'|\n| published\\_at.raw |string|not_analyzed|'08-02-2016'->'08-02-2016'|\n| **updated\\_at** |string|date|'08-02-2016'->'08-02-2016'|\n| updated\\_at.raw |string|not_analyzed|'08-02-2016'->'08-02-2016'|\n| **meta** |object|dynamic|Read more below in dynamic meta mapping|\n"
    }
  ],
  "securityDefinitions": {
    "basic_auth": {
      "type": "basic"
    }
  },
  "paths": {
    "/teaser": {
      "post": {
        "tags": [
          "Teaser"
        ],
        "summary": "Index a single entity",
        "description": "Create a new entity in the index storage",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "description": "The JSON entity to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/Teaser"
            }
          }
        ],
        "security": [
          {
            "basic_auth": []
          }
        ],
        "responses": {
          "201": {
            "description": "Created",
            "schema": {
              "$ref": "#/definitions/BulkTeaserUpdate"
            }
          }
        }
      }
    },
    "/teaser/_bulk": {
      "post": {
        "tags": [
          "Teaser"
        ],
        "summary": "Index an array of entities",
        "description": "Create update or delete an array of enteties",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "description": "The JSON entities to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/BulkBody"
            }
          }
        ],
        "security": [
          {
            "basic_auth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/BulkResponseBody"
            }
          }
        }
      }
    },
    "/teaser/_search": {
      "post": {
        "tags": [
          "Search"
        ],
        "summary": "Search for entities",
        "description": "Submit a search query",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "description": "The JSON entity to create",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SearchBody"
            }
          }
        ],
        "security": [
          {
            "basic_auth": []
          }
        ],
        "responses": {
          "200": {
            "description": "Ok",
            "schema": {
              "$ref": "#/definitions/SearchResponse"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "Tag": {
      "description": "A content category",
      "type": "string",
      "example": ""
    },
    "Category": {
      "description": "A content category",
      "type": "string",
      "example": ""
    },
    "MetaObject": {
      "type": "object",
      "properties": {
        "test_geo_point": {
          "description": "example geo point",
          "type": "string",
          "example": "41.12,-71.34"
        },
        "test_string": {
          "description": "example string",
          "type": "string",
          "example": "an awesome string"
        }
      }
    },
    "BulkResponseCreated": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "The id of the indexed entity",
          "example": "AVhTK1gkV8poqlzpyNyd"
        },
        "status": {
          "type": "integer",
          "description": "The status of the indexed entity 200 for created 201 for updated 400 for error",
          "example": 200
        }
      }
    },
    "BulkResponseUpdated": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "The id of the indexed entity",
          "example": "AVhTKzQKV8poqlzpyNyc"
        },
        "status": {
          "type": "integer",
          "description": "The status of the indexed entity 200 for created 201 for updated 400 for error",
          "example": 201
        }
      }
    },
    "Meta": {
      "type": "object",
      "description": "A bucket that allows custom key values, types are controlled by appeding the _type to the key meaning if the key name is test_string the value will be interpreted and stored as a string\n\n#### Dynamic Meta Mapping\n\nTo further understand the meta object make sure to read the section about [The Meta Object](#meta-object)\n\n| Field  \t\t\t\t\t| Type | Example |\n|:---\t\t\t\t\t\t|:---:|---|\n| **\\*[your\\_field]**\t|not\\_analyzed|'ExamPle' -> 'ExamPle'|\n| *[your\\_field].lowercase\t\t\t\t|lowercase|'ExamPle' -> 'example'|\n| **\\*\\_date** \t\t\t|date|'Kom' -> '08-02-2016'->'08-02-2016'|\n| **\\*\\_boolean** \t\t|boolean|True -> true|\n| **\\*\\_long** \t\t\t|long|2147483647 -> 2147483647 |\n| **\\*\\_integer**  \t\t|integer|32767 -> 32767 |\n| **\\*\\_byte** \t\t\t|byte|01011010 -> 01011010|\n| **\\*\\_double** \t\t\t|double|2.2250738585072020×10−308 -> 2.2250738585072020×10−308|\n| **\\*\\_float** \t\t\t|float|2.2424242 -> 2.2424242|\n| **\\*\\_binary** \t\t\t|binary|010100010 -> 010100010 |\n| **\\*\\_object** \t\t\t|object|{my\\_field: 'Some Field Content'} -> {my\\_field: 'Some Field Content'}|\n| **\\*\\_ip** \t\t\t\t|ip|127.0.0.1 -> 127.0.0.1|\n| **\\*\\_geo_point** \t\t|geo\\_point|{'lat': 41.12, 'lon': -71.34} -> {'lat': 41.12, 'lon': -71.34}|\n| **\\*\\_token_count** \t\t|token\\_count|'Something' -> 9|\n",
      "properties": {
        "test_string": {
          "description": "example string",
          "type": "string",
          "example": "an awesome string"
        },
        "test_integer": {
          "description": "example integer",
          "type": "integer",
          "example": 1
        },
        "test_boolean": {
          "description": "example boolean",
          "type": "boolean",
          "example": true
        },
        "test_long": {
          "description": "example long",
          "type": "number",
          "example": 2.1
        },
        "test_float": {
          "description": "example float",
          "type": "number",
          "example": 2.1
        },
        "test_double": {
          "description": "example double",
          "type": "number",
          "example": 2.1
        },
        "test_byte": {
          "description": "example byte",
          "type": "string",
          "example": 1
        },
        "test_date": {
          "description": "example date",
          "type": "string",
          "example": "2016-02-24T00:00:00.000Z"
        },
        "test_ip": {
          "description": "example ip",
          "type": "string",
          "example": "127.0.0.1"
        },
        "test_geo_point": {
          "description": "example geo point",
          "type": "string",
          "example": "41.12,-71.34"
        },
        "test_object": {
          "$ref": "#/definitions/MetaObject"
        }
      }
    },
    "Teaser": {
      "discriminator": "teaser",
      "type": "object",
      "description": "An example teaser entity could be an article",
      "required": [
        "app_code",
        "brand_code",
        "locale",
        "title",
        "title_teaser",
        "description",
        "description_teaser",
        "image",
        "content_type",
        "url",
        "active",
        "categories",
        "tags"
      ],
      "properties": {
        "app_code": {
          "description": "The app code the content belongs to",
          "type": "string",
          "example": "productsearch"
        },
        "brand_code": {
          "description": "The brand code the content belongs to",
          "type": "string",
          "example": "kom"
        },
        "locale": {
          "description": "The locale for the content",
          "type": "string",
          "enum": [
            "da_dk",
            "sv_se",
            "nb_no",
            "fi_fi",
            "en_gb"
          ]
        },
        "title": {
          "description": "The title for the content",
          "type": "string",
          "example": "An awesome title"
        },
        "title_teaser": {
          "description": "The title for the content",
          "type": "string",
          "example": "An awesome teaser title"
        },
        "description": {
          "description": "The desription for the content",
          "type": "string",
          "example": "An awesome description"
        },
        "description_teaser": {
          "description": "The teaser desription for the content",
          "type": "string",
          "example": "An awesome description"
        },
        "image": {
          "description": "The featured image url",
          "type": "string",
          "example": "http://somedomain.com/aewesome-image.png"
        },
        "content_type": {
          "description": "The content type of the teaser",
          "type": "string",
          "enum": [
            "article",
            "car"
          ]
        },
        "url": {
          "description": "The absolute url to the content",
          "type": "string",
          "example": "http://somedomain.com/aweseome-content"
        },
        "active": {
          "description": "The cotents publish status, 1 for published 0 for non published",
          "type": "integer",
          "enum": [
            0,
            1
          ]
        },
        "categories": {
          "description": "The categories of the content",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Category"
          }
        },
        "tags": {
          "description": "The tags of the content",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Tag"
          }
        },
        "body": {
          "description": "The body of the content",
          "type": "string",
          "example": "An awesome body text"
        },
        "meta": {
          "$ref": "#/definitions/Meta"
        }
      }
    },
    "BulkTeaser": {
      "allOf": [
        {
          "$ref": "#/definitions/Teaser"
        }
      ],
      "properties": {
        "id": {
          "description": "put empty string to create new object",
          "type": "string",
          "example": ""
        }
      }
    },
    "BulkTeaserUpdate": {
      "allOf": [
        {
          "$ref": "#/definitions/Teaser"
        }
      ],
      "properties": {
        "id": {
          "description": "put the id of the object to update existing object",
          "type": "string",
          "example": "AVhTKzQKV8poqlzpyNyc"
        }
      }
    },
    "BulkBody": {
      "description": "An array of teasers to index",
      "type": "array",
      "items": [
        {
          "$ref": "#/definitions/BulkTeaser"
        },
        {
          "$ref": "#/definitions/BulkTeaserUpdate"
        }
      ]
    },
    "BulkResponseBody": {
      "description": "An array of id's and statuses",
      "type": "array",
      "items": [
        {
          "$ref": "#/definitions/BulkResponseCreated"
        },
        {
          "$ref": "#/definitions/BulkResponseUpdated"
        }
      ]
    },
    "SearchHits": {
      "description": "The matching teasers",
      "type": "array",
      "items": [
        {
          "$ref": "#/definitions/BulkTeaserUpdate"
        }
      ]
    },
    "SearchBody": {
      "type": "object",
      "required": [
        "locale"
      ],
      "properties": {
        "locale": {
          "description": "The locale for the content",
          "type": "string",
          "enum": [
            "da_dk",
            "sv_se",
            "nb_no",
            "fi_fi",
            "en_gb"
          ]
        },
        "body": {
          "description": "The raw ElasticSearch query",
          "type": "object"
        }
      }
    },
    "SearchResponse": {
      "type": "object",
      "properties": {
        "total": {
          "description": "The toal number of teasers that match the search",
          "type": "integer",
          "example": 8
        },
        "hits": {
          "$ref": "#/definitions/SearchHits"
        }
      }
    }
  }
}
